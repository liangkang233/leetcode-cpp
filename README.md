# 题目分析

- [x] [1.两数之和](./1.两数之和.cpp)	**[array | hash table]**	

  ​	注意题意，每个输入问题只有一组解

- [x] [2.两数相加](./2.两数相加.cpp)	**[linked-list | math]**	

  ​	看懂题目即可

- [ ] [3.无重复字符的最长子串](./3.无重复字符的最长子串.cpp)	**[hash-table | two-pointers | string | sliding-window ]**	

  ​	做法挺多

- [ ] [4.寻找两个正序数组的中位数](./4.寻找两个正序数组的中位数.cpp)	**[ array | binary-search | divide-and-conquer]**

  ​	使用二分法做，效率很高。注意：无论总个数是奇数还是偶数，其中位数都是第size/2 + 1 和 (size+1)/2)个元素的平均数

- [ ] [5.最长回文子串](./5.最长回文子串.cpp)	**[array | binary-search | divide-and-conquer]**	

  ​	动态规划和贪心的分治

- [x] [6.z-字形变换](./6.z-字形变换.cpp)	**[string]**

- [ ] [7.整数反转](./7.整数反转.cpp)	**[math]**

  ​	不难，但是写的像shit 下次做优雅

- [ ] [8.字符串转换整数-atoi.cpp](./8.字符串转换整数-atoi.cpp)	**[math | string]**

  ​	能想出状态机法确实很难，普通做法类似题目7

- [x] [9.回文数](./9.回文数.cpp) **[math]**

  ​    判断一个数(非string)是否回文的高效方法

- [ ] [10.正则表达式匹配](./10.正则表达式匹配.cpp)	**[string | dynamic-programing | backtracking]**

  ​	经典动态规划，值得多刷

  

- [x] [12.整数转罗马数字](./12.整数转罗马数字.cpp)	**[math | string]**

- [x] [13.罗马数字转整数](./13.罗马数字转整数.cpp)	**[math | string]**

  

- [ ] [22.括号生成](./22.括号生成.cpp)	**[string | backtracking]**

  ​	我理解回溯就是采用了剪枝的最终变量是传参的dfs（普通dfs最终变量不可回溯输出变量）

- [ ] [23.合并k个升序链表](./23.合并k个升序链表.cpp)	**[linked-list | divide-and-conquer | heap]**

  ​	经典分治、优先队列做法，值得多刷

  

- [x] [29.两数相除](./29.两数相除.cpp)	**[math | binary-search]**

  ​	此题有问题，慎做  可以复习下二进制补码的知识

  

- [ ] [32.最长有效括号](./32.最长有效括号.cpp)	**[string | dynamic-programing]**

  ​	可以使用栈的典型题目，也可以用动态规划，值得多刷。还有其他取巧的方法如正序扫一遍再逆序扫一遍。

- [ ] [33.搜索旋转排序数组.](./33.搜索旋转排序数组.cpp)	**[array | binary-search]**

  ​	二分搜索的经典题，**二分**搜索每次都要舍弃一半，从留下的一半中寻找目标；而**分治**法把一个大问题分成两个或多个小问题

  
  
- [ ] [44.通配符匹配](./44.通配符匹配.cpp)    **[string | dynamic-programming | backtracking | greedy]**

  ​	与[10.正则表达式匹配](./10.正则表达式匹配.cpp)类似的做法，多刷 好题 自实现的匹配方案，这里引申下KMP算法:[字符串匹配KMP](./编程之法/字符串匹配KMP.cpp)	

  

- [ ] [53.最大子序和](./53.最大子序和.cpp)    **[array | divide-and-conquer | dynamic-programming]**

  ​	用分治的线段树或是动态规划(推荐)来做都不错，多刷几次

  

- [ ] [56.合并区间](./56.合并区间.cpp)    **[binary-search | dynamic-programming]**

  ​	官方写法更加优雅，下次刷尝试优化

  

- [x] [62.不同路径](./62.不同路径.cpp)    **[array | dynamic-programming]**

- [x] [63.不同路径-ii](./63.不同路径-ii.cpp)    **[array | dynamic-programming]**

- [ ] [64.最小路径和](./64.最小路径和.cpp)    **[array | dynamic-programming]**

  ​	62-64都是动态规划典型题，可以刷下这几个练手复习

  

- [ ] [78.子集](78.子集.cpp)    **[array | backtracking | bit-manipulation]**

  ​	数位操作，这题也算是典型的dfs回溯

  

- [x] [94.二叉树的中序遍历](./94.二叉树的中序遍历.cpp)    **[hash-table | stack | tree]**

  

- [ ] [98.验证二叉搜索树](./98.验证二叉搜索树.cpp)    **[tree | depth-first-search]**

  ​	中序深度递归，Solution3值得思考(二叉搜索树中序一定升序)

  

- [x] [101.对称二叉树](./101.对称二叉树.cpp)    **[tree | depth-first-search | breadth-first-search]**

- [x] [102.二叉树的层序遍历](./102.二叉树的层序遍历.cpp)    **[tree | breadth-first-search]**

  

- [x] [120.三角形最小路径和](./120.三角形最小路径和.cpp)    **[array | dynamic-programming]**

  

- [ ] [131.分割回文串](./131.分割回文串.cpp)    **[backtracking]**

  这道题需要考虑优化问题，可惜测试样例没有给大量的数据使用普通回文判断不会超时

  

- [x] [136.只出现一次的数字](./136.只出现一次的数字.cpp)    **[]**

  ​	貌似是第一次做leetcode的题，印象深刻

- [ ] [137.只出现一次的数字-ii.cpp](./137.只出现一次的数字-ii.cpp)    **[bit-manipulation]**

  ​	数字电路的做法超级秀，常规哈希，高级点做法就是将数位拆分

  

- [x] [141.环形链表](./141.环形链表.cpp)    **[linked-list | two-pointers]**

- [ ] [142.环形链表-ii](./142.环形链表-ii.cpp)    **[linked-list | two-pointers]**

  ​	双指针典型应用，建议再做一遍，注意**链表值**可能相等 需要判断指针是否相等

- [ ] [143.重排链表](./143.重排链表.cpp)    **[linked-list]**

  ​	算是链表的综合应用，快慢指针找中点，再链表反转、合并。参考[876.链表的中间结点](./876.链表的中间结点.cpp) [206.反转链表](./206.反转链表.cpp)

  

- [ ] [146.lru-缓存机制.cpp](./146.lru-缓存机制.cpp)    **[design]**

  ​	这道题有意思，map记录节点key，实际cache用双向链表。答案中使用自己实现的双向链表，最好直接用std的list。这里有个技巧：**双向链表加一个伪头 伪尾，可以减少很多判断左右为空的操作 和 初始化赋值的操作**

  
  
  
  
- [ ] [153.寻找旋转排序数组中的最小值](./153.寻找旋转排序数组中的最小值.cpp)    **[array | binary-search]**

  ​	说实话，153 154 引导的不是很好，sort直接排序效果也很好。应该要求限制时间复杂度为logn，这里使用二分的前提是要各个元素不相同。

- [ ] [154.寻找旋转排序数组中的最小值-ii](./154.寻找旋转排序数组中的最小值-ii.cpp)    **[array | binary-search]**

  ​	此题给出数组允许了数据重复，不能直接如上做。


- [ ] [205.同构字符串](./205.同构字符串.cpp)	**[hash-table]**

  ​	不需要两个哈希表，用一个数组的空间就可以做到一一对应，系列题目[890.查找和替换模式](./890.查找和替换模式.cpp)

- [x] [206.反转链表](./206.反转链表.cpp)    **[linked-list]**

  

- [x] [263.丑数](./263.丑数.cpp)	**[math]**

  ​	系列题目 264、265、[313.超级丑数](./313.超级丑数.cpp)

- [ ] [264.丑数II](./264.丑数-ii.cpp)	**[math | dynamic-programming | heap]]**

  ​	直接用两个容器动态规划会超时，需要优化。也可以使用堆(优先队列)

  

- [ ] [313.超级丑数](./313.超级丑数.cpp)	**[math | heap]**

  ​	题目[264](./264.丑数-ii.cpp)的升级做法，使用官方的优先队列会超时？？
  
  


- [ ] [547.省份数量](./547.省份数量.cpp) 	**[depth-first-search | union-find]**

  ​	经典的并查集问题，注意路径压缩与按秩归并

  

- [x] [605.种花问题](./605.种花问题.cpp)    **[array]**

  ​	vivo面试题

  


- [ ] [621.任务调度器](./621.任务调度器.cpp)    **[array | greedy | queue]**

  ​	先取出并以出现次数频率作为排序依据，解题需要穷举几次发现规律，比较难想到

  

- [ ] [623.在二叉树中增加一行](./623.在二叉树中增加一行.cpp)    **[tree | dfs]**

  ​	dfs的应用，一定按照题意对depth-1行操作，吃了这个亏花了很长时间才发现题目理解错了，添加的那行树的左右子树顺序是有要求的

  

- [ ] [876.链表的中间结点.cpp](./876.链表的中间结点.cpp)    **[ordered-map | linked-list | two-pointers]**

  ​	注意题中输出要求，使用双指针做

  

- [ ] [887.鸡蛋掉落](./887.鸡蛋掉落.cpp)    **[heap]**

  ​	双蛋问题，google经典面试题，2020 vivo提前批。第一次做思路出了问题，解决部分。这道题常规做法用到 二分法 + 动态规划。官方解法3的逆向思维可以了解下。

  

- [ ] [889.根据前序和后序遍历构造二叉树](./889.根据前序和后序遍历构造二叉树.cpp)	**[string | tree]**

  ​	先回顾二叉树前中后序列区别，注意题中说明 二叉树中的各个值不相同,不需要考虑不成立的情况

- [ ] [890.查找和替换模式](./890.查找和替换模式.cpp)	**[greedy]**

  ​	题目[205](./205.同构字符串.cpp)、类似做法直接双重映射或者单重映射搭配数组记录次数，（单重映射只能保证一对多，不能一一对应）

  ​	第一次做时打算用个数来做少考虑了部分情况。直接用数组下标做映射也是可以的（推荐）

- [ ] [891.子序列宽度之和](./891.子序列宽度之和.cpp)	**[greedy]**	

  ​	有难度，找公式。
  
  


- [ ] [925.长按键入](./925.长按键入.cpp)    **[tree]**

  ​	第一次写的很烂，思路跟答案差不多，很多情况没考虑到。
  
  
  
- [ ] [1568.使陆地分离的最少天数](./1568.使陆地分离的最少天数.cpp)	**[unkown]**

  ​	脑经急转弯。。 



# 注意点：

- 序列：
  - 子序列元素相同并不代表是同一子序列，只要子序列元素索引不同即为不同子序列，子集合才是考虑元素不同（题目 891）
- 二叉树：
  - 前序/后序+中序序列可以唯一确定一棵二叉树，只知道前序和后序不唯一确定 参考[蓝桥杯例题](E:\Task\算法相关\二叉树\由前(后)序和中序 推导至后(中)序.cpp) 和[题目889](./889.根据前序和后序遍历构造二叉树.cpp)

- leetcode输入测试：
  - 若是例如[44.通配符匹配](./44.通配符匹配.cpp)的类似多个string时外面还要加""，例如输入```s="io" p="io*" ```时，应该是输入 ```""io"\n"io*""```

- size() 返回值为无符号数，其与负数相比较时负数会转为无符号数，所以判断结果会出问题。一定要在判断前转为int。