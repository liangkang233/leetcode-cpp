# 题目分析

- [x] [1.两数之和](./1.两数之和.cpp)	**[array | hash table]**	

  ​	注意题意，每个输入问题只有一组解

- [x] [2.两数相加](./2.两数相加.cpp)	**[linked-list | math]**	

  ​	看懂题目即可

- [ ] [3.无重复字符的最长子串](./3.无重复字符的最长子串.cpp)	**[hash-table | two-pointers | string | sliding-window ]**	

  ​	做法挺多

- [ ] [4.寻找两个正序数组的中位数](./4.寻找两个正序数组的中位数.cpp)	**[ array | binary-search | divide-and-conquer]**

  ​	使用二分法做，效率很高。注意：无论总个数是奇数还是偶数，其中位数都是第size/2 + 1 和 (size+1)/2)个元素的平均数

- [ ] [5.最长回文子串](./5.最长回文子串.cpp)	**[array | binary-search | divide-and-conquer]**	

  ​	动态规划和贪心的分治 扩展题[516.最长回文子序列](./516.最长回文子序列.cpp)

- [x] [6.z-字形变换](./6.z-字形变换.cpp)	**[string]**

- [ ] [7.整数反转](./7.整数反转.cpp)	**[math]**

  ​	不难，但是写的像shit 下次做优雅

- [ ] [8.字符串转换整数-atoi.cpp](./8.字符串转换整数-atoi.cpp)	**[math | string]**

  ​	能想出状态机法确实很难，普通做法类似题目7

- [x] [9.回文数](./9.回文数.cpp) **[math]**

  ​    判断一个数(非string)是否回文的高效方法

- [ ] [10.正则表达式匹配](./10.正则表达式匹配.cpp)	**[string | dynamic-programing | backtracking]**

  ​	经典动态规划，值得多刷

- [ ] [11.盛最多水的容器](./11.盛最多水的容器.cpp)    **[array | two-pointers]**

  ​	直接暴力法会超时，需要优化下

- [x] [12.整数转罗马数字](./12.整数转罗马数字.cpp)	**[math | string]**

- [x] [13.罗马数字转整数](./13.罗马数字转整数.cpp)	**[math | string]**

  

- [ ] [22.括号生成](./22.括号生成.cpp)	**[string | backtracking]**

  ​	我理解回溯就是采用了剪枝的最终变量是传参的dfs（普通dfs最终变量不可回溯输出变量）

- [ ] [23.合并k个升序链表](./23.合并k个升序链表.cpp)	**[linked-list | divide-and-conquer | heap]**

  ​	经典分治、优先队列做法，值得多刷

  

- [x] [29.两数相除](./29.两数相除.cpp)	**[math | binary-search]**

  ​	此题有问题，慎做  可以复习下二进制补码的知识

  

- [ ] [32.最长有效括号](./32.最长有效括号.cpp)	**[string | dynamic-programing]**

  ​	可以使用栈的典型题目，也可以用动态规划，值得多刷。还有其他取巧的方法如正序扫一遍再逆序扫一遍。

- [ ] [33.搜索旋转排序数组.](./33.搜索旋转排序数组.cpp)	**[array | binary-search]**

  ​	二分搜索的经典题，**二分**搜索每次都要舍弃一半，从留下的一半中寻找目标；而**分治**法把一个大问题分成两个或多个小问题

  
  
- [ ] [36.有效的数独](./36.有效的数独.cpp)    **[hash-table]**

  ​	注意 & 优先级比 == 低 比&&高，这里吃了忘加括号的坑，   一道不错的测试bitmap题目

- [ ] [37.解数独](./37.解数独.cpp)    **[hash-table | backtracking ]**

  ​	一开始需要填入已经存在的值作为初始值，其次回溯要注意的点这题都有，很经典 n皇后 类似

  

- [ ] [44.通配符匹配](./44.通配符匹配.cpp)    **[string | dynamic-programming | backtracking | greedy]**

  ​	与[10.正则表达式匹配](./10.正则表达式匹配.cpp)类似的做法，多刷 好题 自实现的匹配方案，这里引申下KMP算法:[字符串匹配KMP](./编程之法/字符串匹配KMP.cpp)	

- [ ] [45.跳跃游戏-ii](./45.跳跃游戏-ii.cpp)    **[array | greedy]**

  ​	系列题目[55.跳跃游戏](./55.跳跃游戏.cpp) 贪心即可不要想复杂了用dp

- [ ] [46.全排列](./46.全排列.cpp)    **[backtracking]**

  ​	典型回溯，不要混淆了全排列和全子集的区别（全子集可以有重复，全排列不可，题中元素无重复 可以做全子集的）

- [ ] [47.全排列-ii](./47.全排列-ii.cpp)    **[backtracking]**

  ​	其实c++std库里有全排列的函数 *next_permutation* （）这两题要二刷，当时写的时候没想清楚

  

- [ ] [51.n-皇后](./51.n-皇后.cpp)    **[backtracking]**

- [ ] [52.n皇后-ii](./52.n皇后-ii.cpp)    **[backtracking]**

  ​	经典回溯问题，跟51相同

- [ ] [53.最大子序和](./53.最大子序和.cpp)    **[array | divide-and-conquer | dynamic-programming]**

  ​	用分治的线段树或是动态规划(推荐)来做都不错，多刷几次

- [ ] [54.螺旋矩阵](./54.螺旋矩阵.cpp)    **[array]**

  ​	这个判断条件没想到写的这么恼火

- [ ] [55.跳跃游戏](./55.跳跃游戏.cpp)    **[array | greedy]**

  ​	系列题目[45.跳跃游戏-ii](./45.跳跃游戏-ii.cpp) 贪心即可不要想复杂了用dp

- [ ] [56.合并区间](./56.合并区间.cpp)    **[binary-search | dynamic-programming]**

  ​	官方写法更加优雅，下次刷尝试优化

  

- [ ] [59.螺旋矩阵-ii](./59.螺旋矩阵-ii.cpp)    **[array]**

  ​	[54.螺旋矩阵](./54.螺旋矩阵.cpp) 类似题，解法差不多  此题用count下标似乎效果好些

  

- [x] [62.不同路径](./62.不同路径.cpp)    **[array | dynamic-programming]**

- [x] [63.不同路径-ii](./63.不同路径-ii.cpp)    **[array | dynamic-programming]**

- [ ] [64.最小路径和](./64.最小路径和.cpp)    **[array | dynamic-programming]**

  ​	62-64都是动态规划典型题，可以刷下这几个练手复习

  

- [ ] [78.子集](78.子集.cpp)    **[array | backtracking | bit-manipulation]**

  ​	数位操作，这题也算是典型的dfs回溯

  

- [x] [94.二叉树的中序遍历](./94.二叉树的中序遍历.cpp)    **[hash-table | stack | tree]**

  

- [ ] [98.验证二叉搜索树](./98.验证二叉搜索树.cpp)    **[tree | depth-first-search]**

  ​	中序深度递归，Solution3值得思考(二叉搜索树中序一定升序)

  

- [x] [101.对称二叉树](./101.对称二叉树.cpp)    **[tree | depth-first-search | breadth-first-search]**

- [x] [102.二叉树的层序遍历](./102.二叉树的层序遍历.cpp)    **[tree | breadth-first-search]**

  

- [x] [120.三角形最小路径和](./120.三角形最小路径和.cpp)    **[array | dynamic-programming]**

  

- [ ] [131.分割回文串](./131.分割回文串.cpp)    **[backtracking]**

  这道题需要考虑优化问题，可惜测试样例没有给大量的数据使用普通回文判断不会超时

  

- [x] [136.只出现一次的数字](./136.只出现一次的数字.cpp)    **[]**

  ​	貌似是第一次做leetcode的题，印象深刻

- [ ] [137.只出现一次的数字-ii.cpp](./137.只出现一次的数字-ii.cpp)    **[bit-manipulation]**

  ​	数字电路的做法超级秀，常规哈希，高级点做法就是将数位拆分

  

- [x] [141.环形链表](./141.环形链表.cpp)    **[linked-list | two-pointers]**

- [ ] [142.环形链表-ii](./142.环形链表-ii.cpp)    **[linked-list | two-pointers]**

  ​	双指针典型应用，建议再做一遍，注意**链表值**可能相等 需要判断指针是否相等

- [ ] [143.重排链表](./143.重排链表.cpp)    **[linked-list]**

  ​	算是链表的综合应用，快慢指针找中点，再链表反转、合并。参考[876.链表的中间结点](./876.链表的中间结点.cpp) [206.反转链表](./206.反转链表.cpp)

  

- [ ] [146.lru-缓存机制.cpp](./146.lru-缓存机制.cpp)    **[design]**

  ​	这道题有意思，map记录节点key，实际cache用双向链表。答案中使用自己实现的双向链表，最好直接用std的list。这里有个技巧：**双向链表加一个伪头 伪尾，可以减少很多判断左右为空的操作 和 初始化赋值的操作**

  

  

- [ ] [153.寻找旋转排序数组中的最小值](./153.寻找旋转排序数组中的最小值.cpp)    **[array | binary-search]**

  ​	说实话，153 154 引导的不是很好，sort直接排序效果也很好。应该要求限制时间复杂度为logn，这里使用二分的前提是要各个元素不相同。

- [ ] [154.寻找旋转排序数组中的最小值-ii](./154.寻找旋转排序数组中的最小值-ii.cpp)    **[array | binary-search]**

  ​	此题给出数组允许了数据重复，不能直接如上做。


- [ ] [205.同构字符串](./205.同构字符串.cpp)	**[hash-table]**

  ​	不需要两个哈希表，用一个数组的空间就可以做到一一对应，系列题目[890.查找和替换模式](./890.查找和替换模式.cpp)

- [x] [206.反转链表](./206.反转链表.cpp)    **[linked-list]**

  

- [x] [263.丑数](./263.丑数.cpp)	**[math]**

  ​	系列题目 264、265、[313.超级丑数](./313.超级丑数.cpp)

- [ ] [264.丑数II](./264.丑数-ii.cpp)	**[math | dynamic-programming | heap]]**

  ​	直接用两个容器动态规划会超时，需要优化。也可以使用堆(优先队列)

  

- [ ] [313.超级丑数](./313.超级丑数.cpp)	**[math | heap]**

  ​	题目[264](./264.丑数-ii.cpp)的升级做法，使用官方的优先队列会超时？？
  
  
  
- [ ] [343.整数拆分](./343.整数拆分.cpp)    **[math | dynamic-programming]**

  ​	基本的动态规划

- [x] [344.反转字符串](./344.反转字符串.cpp)    **[two-pointers | string]**

  ​	

- [ ] [378.有序矩阵中第-k-小的元素](./378.有序矩阵中第-k-小的元素.cpp)    **[binary-search | heap]**

  ​	最优解是二分法，当然也可使用优先队列（较差） 归并（最差）也可 

  

- [ ] [410.分割数组的最大值](./410.分割数组的最大值.cpp)    **[binary-search | dynamic-programming]**

  ​	又是一道二分最优解 动态规划也可

  

- [ ] [429.n-叉树的层序遍历](./429.n-叉树的层序遍历.cpp)    **[]**

  ​	二叉树的层次遍历bfs的稍变形

  

- [ ] [451.根据字符出现频率排序](./451.根据字符出现频率排序.cpp)    **[hash-table | heap]**

  ​	桶排序效果也不错

  ​	

- [ ] [464.我能赢吗](./464.我能赢吗.cpp)    **[dynamic-programming | minimax]**

  ​	[292.nim-游戏](./292.nim-游戏.cpp)的扩展，一道很经典的博弈题，动态规划

  ​	

- [ ] [516.最长回文子序列](./516.最长回文子序列.cpp)    **[]**

  ​	[5.最长回文子串](./5.最长回文子串.cpp)扩展，这个动态规划可以压缩为一维的做优化。不过能ac就行，没必要为了这点空间做优化。

  ​	

- [x] [541.反转字符串-ii](./541.反转字符串-ii.cpp)    **[string]**

  ​	


- [ ] [547.省份数量](./547.省份数量.cpp) 	**[depth-first-search | union-find]**

  ​	经典的并查集问题，注意路径压缩与按秩归并

  

- [x] [557.反转字符串中的单词-iii](./557.反转字符串中的单词-iii.cpp)    **[string]**

  

- [x] [605.种花问题](./605.种花问题.cpp)    **[array]**

  ​	vivo面试题

  


- [ ] [621.任务调度器](./621.任务调度器.cpp)    **[array | greedy | queue]**

  ​	先取出并以出现次数频率作为排序依据，解题需要穷举几次发现规律，比较难想到

  

- [ ] [623.在二叉树中增加一行](./623.在二叉树中增加一行.cpp)    **[tree | dfs]**

  ​	dfs的应用，一定按照题意对depth-1行操作，吃了这个亏花了很长时间才发现题目理解错了，添加的那行树的左右子树顺序是有要求的

  

- [ ] [705.设计哈希集合](./705.设计哈希集合.cpp)    **[Unknown]**

  ​	有意思，设计list容器。list使用std就好，自己写要维护链表头尾比较麻烦

  

- [ ] [779.第k个语法符号](./779.第k个语法符号.cpp)    **[array]**

  ​	找规律即可

  

- [ ] [784.字母大小写全排列](./784.字母大小写全排列.cpp)    **[ordered-map]**

  ​	与[46.全排列](./46.全排列.cpp)  [47.全排列-ii](./47.全排列-ii.cpp) 有点像，注意要保留无变化的

  

- [ ] [876.链表的中间结点.cpp](./876.链表的中间结点.cpp)    **[ordered-map | linked-list | two-pointers]**

  ​	注意题中输出要求，使用双指针做

  

- [ ] [887.鸡蛋掉落](./887.鸡蛋掉落.cpp)    **[heap]**

  ​	双蛋问题，google经典面试题，2020 vivo提前批。第一次做思路出了问题，解决部分。这道题常规做法用到 二分法 + 动态规划。官方解法3的逆向思维可以了解下。

  

- [ ] [889.根据前序和后序遍历构造二叉树](./889.根据前序和后序遍历构造二叉树.cpp)	**[string | tree]**

  ​	先回顾二叉树前中后序列区别，注意题中说明 二叉树中的各个值不相同,不需要考虑不成立的情况

- [ ] [890.查找和替换模式](./890.查找和替换模式.cpp)	**[greedy]**

  ​	题目[205](./205.同构字符串.cpp)、类似做法直接双重映射或者单重映射搭配数组记录次数，（单重映射只能保证一对多，不能一一对应）

  ​	第一次做时打算用个数来做少考虑了部分情况。直接用数组下标做映射也是可以的（推荐）

- [ ] [891.子序列宽度之和](./891.子序列宽度之和.cpp)	**[greedy]**	

  ​	有难度，找公式。
  
  


- [ ] [925.长按键入](./925.长按键入.cpp)    **[tree]**

  ​	第一次写的很烂，思路跟答案差不多，很多情况没考虑到。
  
  
  
- [ ] [1006.笨阶乘.cpp](./1006.笨阶乘.cpp)    **[hash-table | string]**

  

- [ ] [1024.视频拼接](./1024.视频拼接.cpp)    **[greedy | dynamic-programming]**

  

- [ ] [1111.有效括号的嵌套深度](./1111.有效括号的嵌套深度.cpp)    **[dynamic-programming]**

  ​	第一想法就是用栈做，没想到这题也可以动态规划

  

- [ ] [1353.最多可以参加的会议数目](./1353.最多可以参加的会议数目.cpp)    **[unkown]**

  ​	贪心优先队列，算是应用题了

  

- [ ] [1568.使陆地分离的最少天数](./1568.使陆地分离的最少天数.cpp)	**[unkown]**

  ​	脑经急转弯。。 

  

- [ ] [1594.矩阵的最大非负积.cpp](./1594.矩阵的最大非负积.cpp)    **[unkown]**

  ​	万能的DP

  

- [ ] [1664.生成平衡数组的方案数.cpp](./1664.生成平衡数组的方案数.cpp)    **[unkown]**

  

- [ ] [1935.可以输入的最大单词数](./1935.可以输入的最大单词数.cpp)    **[unkown]**

  ​	注意边界和最后一个单词

  

- [ ] [1953.你可以工作的最大周数](./1953.你可以工作的最大周数.cpp)    **[unkown]**

# 注意点：

- 序列：
  - 子序列元素相同并不代表是同一子序列，只要子序列元素索引不同即为不同子序列，子集合才是考虑元素不同（题目 891）
- 二叉树：
  - 前序/后序+中序序列可以唯一确定一棵二叉树，只知道前序和后序不唯一确定 参考[蓝桥杯例题](E:\Task\算法相关\二叉树\由前(后)序和中序 推导至后(中)序.cpp) 和[题目889](./889.根据前序和后序遍历构造二叉树.cpp)

- leetcode输入测试：
  - 若是例如[44.通配符匹配](./44.通配符匹配.cpp)的类似多个string时外面还要加""，例如输入```s="io" p="io*" ```时，应该是输入 ```""io"\n"io*""```
  - 非文件的话多个参数使用\n分隔，文件的话直接回车分行即可。
  
- size() 返回值为无符号数，其与负数相比较时负数会转为无符号数，所以判断结果会出问题。一定要在判断前转为int。