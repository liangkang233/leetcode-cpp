# 题目分析

- [x] [1.两数之和](E:\Task\LeetCode\1.两数之和.cpp)	**[array | hash table]**	

  ​	注意题意，每个输入问题只有一组解

- [x] [2.两数相加](E:\Task\LeetCode\2.两数相加.cpp)	**[linked-list | math]**	

  ​	看懂题目即可

- [ ] [3.无重复字符的最长子串](E:\Task\LeetCode\3.无重复字符的最长子串.cpp)	**[hash-table | two-pointers | string | sliding-window ]**	

  ​	做法挺多

- [ ] [4.寻找两个正序数组的中位数](E:\Task\LeetCode\4.寻找两个正序数组的中位数.cpp)	**[ array | binary-search | divide-and-conquer]**

  ​	使用二分法做，效率很高

- [ ] [5.最长回文子串](E:\Task\LeetCode\5.最长回文子串.cpp)	**[array | binary-search | divide-and-conquer]**	

  ​	动态规划和贪心的分治

- [x] [6.z-字形变换](E:\Task\LeetCode\6.z-字形变换.cpp)	**[string]**

- [ ] [7.整数反转](E:\Task\LeetCode\7.整数反转.cpp)	**[math]**

  ​	不难，但是写的像shit 下次做优雅

- [ ] [8.字符串转换整数-atoi.cpp](E:\Task\LeetCode\8.字符串转换整数-atoi.cpp)	**[math | string]**

  ​	能想出状态机法确实很难，普通做法类似题目7

- [x] [9.回文数](E:\Task\LeetCode\9.回文数.cpp) **[math]**

  ​    判断一个数(非string)是否回文的高效方法

- [ ] [10.正则表达式匹配](E:\Task\LeetCode\10.正则表达式匹配.cpp)	**[string | dynamic-programing | backtracking]**

  ​	经典动态规划，值得多刷

  

- [x] [12.整数转罗马数字](E:\Task\LeetCode\12.整数转罗马数字.cpp)	**[math | string]**

- [x] [13.罗马数字转整数](E:\Task\LeetCode\13.罗马数字转整数.cpp)	**[math | string]**

  

- [ ] [22.括号生成](E:\Task\LeetCode\22.括号生成.cpp)	**[string | backtracking]**

  ​	我理解回溯就是采用了剪枝的最终变量是传参的dfs（普通dfs最终变量不可回溯输出变量）

- [ ] [23.合并k个升序链表](E:\Task\LeetCode\23.合并k个升序链表.cpp)	**[linked-list | divide-and-conquer | heap]**

  ​	经典分治、优先队列做法，值得多刷

  

- [x] [29.两数相除](E:\Task\LeetCode\29.两数相除.cpp)	**[math | binary-search]**

  ​	此题有问题，慎做  可以复习下二进制补码的知识

  

- [ ] [32.最长有效括号](E:\Task\LeetCode\32.最长有效括号.cpp)	**[string | dynamic-programing]**

  ​	可以使用栈的典型题目，也可以用动态规划，值得多刷。还有其他取巧的方法如正序扫一遍再逆序扫一遍。

- [ ] [33.搜索旋转排序数组.](E:\Task\LeetCode\33.搜索旋转排序数组.cpp)	**[array | binary-search]**

  ​	二分搜索的经典题，**二分**搜索每次都要舍弃一半，从留下的一半中寻找目标；而**分治**法把一个大问题分成两个或多个小问题*

  


- [ ] [205.同构字符串.cpp](E:\Task\LeetCode\205.同构字符串.cpp)	**[hash-table]**

  ​	用一个数组的空间就可以做到一一对应，系列题目[890](E:\Task\LeetCode\890.查找和替换模式.cpp)

  

- [x] [263.丑数](E:\Task\LeetCode\263.丑数.cpp)	**[math]**

  ​	系列题目 264、265、[313](E:\Task\LeetCode\313.超级丑数.cpp)

- [ ] [264.丑数II](E:\Task\LeetCode\264.丑数-ii.cpp)	**[math | dynamic-programming | heap]]**

  ​	直接用两个容器动态规划会超时，需要优化。也可以使用堆(优先队列)

  

- [ ] [313.超级丑数](E:\Task\LeetCode\313.超级丑数.cpp)	**[math | heap]**

  ​	题目[264](E:\Task\LeetCode\264.丑数-ii.cpp)的升级做法，使用官方的优先队列会超时？？




- [ ] [547.省份数量](E:\Task\LeetCode\547.省份数量.cpp) 	**[depth-first-search | union-find]**

  ​	经典的并查集问题，注意路径压缩与按秩归并

  

  

- [ ] 621.

- [ ] 623.

- [ ] [809.查找和替换模式](E:\Task\LeetCode\890.查找和替换模式.cpp)	**[greedy]**

  ​	题目[205](E:\Task\LeetCode\205.同构字符串.cpp)、类似做法直接双重映射或者单重映射搭配数组记录次数，（单重映射只能保证一对多，不能一一对应）

  ​	第一次做时打算用个数来做少考虑了部分情况。直接用数组下标做映射也是可以的（推荐）

  

- [ ] [889.根据前序和后序遍历构造二叉树](E:\Task\LeetCode\889.根据前序和后序遍历构造二叉树.cpp)	**[string | tree]**

  ​	先回顾二叉树前中后序列区别，注意题中说明 二叉树中的各个值不相同,不需要考虑不成立的情况

  

- [ ] [891.子序列宽度之和](E:\Task\LeetCode\891.子序列宽度之和.cpp)	**[greedy]**	

  ​	有难度，找公式。



# 注意点：

- 序列：
  - 子序列元素相同并不代表是同一子序列，只要子序列元素索引不同即为不同子序列，子集合才是考虑元素不同（题目 891）
- 二叉树：
  - 前序/后序+中序序列可以唯一确定一棵二叉树，只知道前序和后序不唯一确定 参考[蓝桥杯例题](E:\Task\算法相关\二叉树\由前(后)序和中序 推导至后(中)序.cpp) 和[题目889](E:\Task\LeetCode\889.根据前序和后序遍历构造二叉树.cpp)